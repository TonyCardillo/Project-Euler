'''
Euler Project :: Problem 12

Language: Python
Started: 9/2/2021
Solved:  M/DD/YYYY
Speed (best of 3): 5.34 seconds

Description:
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

Correct Answer:
76,576,500

Notes:
This seems like a perfect time to learn about generators. I don't know my upper-bound on generating triangle numbers, so let's start there!


'''

# Ignore importation of time module for timing purposes
import time
startTime = time.time()

# Import math for square root
import math

# Generator for "triangle numbers"
def fnTriangleNumberGenerator():
    '''Generator for triangle numbers. Output: int from generator'''
    storedNumber = 1 # We start with 1
    storedIncrement = 2 # And we increment by 2 to begin with
    yield 1
    while True:
        storedNumber = storedNumber+storedIncrement
        yield storedNumber
        storedIncrement += 1 # Increment after yielding the value, in the hopes of magical parallel processing

def fnCountDivisors(number: int):
    '''Informed brute-force that returns number of divisors as int.
    Since we don't care about the divisors themselves, this may be slightly quicker
    '''
    if number == 1:
        return 1

    coDivisors = 0 # Start with a count-of 0 divisors
    upperBound = math.floor(math.sqrt(number)) # We only need to check up to sqrt(n)

    # Branch by simplest case, a sort of wheel-implementation
    if number % 2 == 0:
        coDivisors += 1 # For having 2 as a factor
        # Even number, proceed with all numbers (i.e. may be divisible by 4, 6, 8, etc.)
        for factor in range(3,upperBound):
            if number % factor == 0:
                coDivisors += 1
    else:
        # Odd number, don't need to test any more even numbers (cannot possibly be divisible by 4, 6, etc.)
        for factor in range(3,upperBound,2):
            if number % factor == 0:
                coDivisors += 1
    coDivisors *= 2 # All divisors are pairs, and we found the lower number of the pair, so multiply coDivisors by 2
    coDivisors += 2 # Each number is divisible between 1) 1, and 2) itself
    return coDivisors

# While we haven't found a number with more than 500 divisors...
triangleNumber = fnTriangleNumberGenerator()
coDivisors = 1 
while coDivisors <= 500:
    candidate = next(triangleNumber)
    coDivisors = fnCountDivisors(candidate)

endTime = time.time()
print("{} milliseconds".format(1000.0*(endTime - startTime)))

# THE ANSWER
print(candidate)

# Gracefully quit
quit()

